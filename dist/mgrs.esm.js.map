{"version":3,"file":"mgrs.esm.js","sources":["../mgrs.js"],"sourcesContent":["/**\r\n * UTM zones are grouped, and assigned to one of a group of 6\r\n * sets.\r\n *\r\n * {int} @private\r\n */\r\nconst NUM_100K_SETS = 6;\r\n\r\n/**\r\n * The column letters (for easting) of the lower left value, per\r\n * set.\r\n *\r\n * {string} @private\r\n */\r\nconst SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\r\n\r\n/**\r\n * The row letters (for northing) of the lower left value, per\r\n * set.\r\n *\r\n * {string} @private\r\n */\r\nconst SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\r\n\r\nconst A = 65; // A\r\nconst I = 73; // I\r\nconst O = 79; // O\r\nconst V = 86; // V\r\nconst Z = 90; // Z\r\n\r\n/**\r\n * First eccentricity squared\r\n * {number} @private\r\n */\r\nconst ECC_SQUARED = 0.00669438;\r\n\r\n/**\r\n * Scale factor along the central meridian\r\n * {number} @private\r\n */\r\nconst SCALE_FACTOR = 0.9996;\r\n\r\n/**\r\n * Semimajor axis (half the width of the earth) in meters\r\n * {number} @private\r\n */\r\nconst SEMI_MAJOR_AXIS = 6378137;\r\n\r\n/**\r\n * The easting of the central meridian of each UTM zone\r\n * {number} @private\r\n */\r\nconst EASTING_OFFSET = 500000;\r\n\r\n/**\r\n * The northing of the equator for southern hemisphere locations (in UTM)\r\n * {number} @private\r\n */\r\nconst NORTHING_OFFFSET = 10000000;\r\n\r\n/**\r\n * UTM zone width in degrees\r\n * {number} private\r\n */\r\nconst UTM_ZONE_WIDTH = 6;\r\n\r\n/**\r\n * Half the width of a UTM zone in degrees\r\n * {number} private\r\n */\r\nconst HALF_UTM_ZONE_WIDTH = UTM_ZONE_WIDTH / 2;\r\n\r\n/**\r\n * Convert lat/lon to MGRS.\r\n *\r\n * @param {[number, number]} ll Array with longitude and latitude on a\r\n *     WGS84 ellipsoid.\r\n * @param {number} [accuracy=5] Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\r\n *      100 m, 2 for 1 km, 1 for 10 km or 0 for 100 km). Optional, default is 5.\r\n * @return {string} the MGRS string for the given location and accuracy.\r\n */\r\nexport function forward(ll, accuracy) {\r\n  accuracy = typeof accuracy === 'number' ? accuracy : 5; // default accuracy 1m\r\n\r\n  if (!Array.isArray(ll)) {\r\n    throw new TypeError('forward did not receive an array');\r\n  }\r\n\r\n  if (typeof ll[0] === 'string' || typeof ll[1] === 'string') {\r\n    throw new TypeError('forward received an array of strings, but it only accepts an array of numbers.');\r\n  }\r\n\r\n  const [ lon, lat ] = ll;\r\n  if (lon < -180 || lon > 180) {\r\n    throw new TypeError(`forward received an invalid longitude of ${lon}`);\r\n  }\r\n  if (lat < -90 || lat > 90) {\r\n    throw new TypeError(`forward received an invalid latitude of ${lat}`);\r\n  }\r\n\r\n  if (lat < -80 || lat > 84) {\r\n    throw new TypeError(`forward received a latitude of ${lat}, but this library does not support conversions of points in polar regions below 80°S and above 84°N`);\r\n  }\r\n\r\n  return encode(LLtoUTM({ lat, lon }), accuracy);\r\n}\r\n\r\n/**\r\n * Convert MGRS to lat/lon bounding box.\r\n *\r\n * @param {string} mgrs MGRS string.\r\n * @return {[number,number,number,number]} An array with left (longitude),\r\n *    bottom (latitude), right\r\n *    (longitude) and top (latitude) values in WGS84, representing the\r\n *    bounding box for the provided MGRS reference.\r\n */\r\nexport function inverse(mgrs) {\r\n  const bbox = UTMtoLL(decode(mgrs.toUpperCase()));\r\n  if (typeof bbox.lat === 'number' && typeof bbox.lon === 'number') {\r\n    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\r\n  }\r\n  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\r\n}\r\n\r\n/**\r\n * Convert MGRS to lat/lon polygon.\r\n *  \r\n * * @param {string} mgrs MGRS string.\r\n * * @return {[number,number][]} An array of arrays with longitude and latitude\r\n * *    values in WGS84, representing the corners of the polygon for the\r\n * *    provided MGRS reference.\r\n * */\r\n\r\n\r\nexport function polygon(mgrsString) {\r\n  // 1. Convert MGRS to UTM\r\n\r\n\r\n  // 2. Get UTM zone and easting/northing\r\n  const utm = decode(mgrsString.toUpperCase());\r\n\r\n  // 3. Calculate bounding corners using true UTM math\r\n  const eastingMin = Math.floor(utm.easting / 10000) * 10000;\r\n  const northingMin = Math.floor(utm.northing / 10000) * 10000;\r\n  const eastingMax = eastingMin + 10000;\r\n  const northingMax = northingMin + 10000;\r\n\r\n  const bottomLeft = UTMtoLL({ easting: eastingMin, northing: northingMin, zoneNumber: utm.zoneNumber, zoneLetter: utm.zoneLetter });\r\n  const bottomRight = UTMtoLL({ easting: eastingMax, northing: northingMin, zoneNumber: utm.zoneNumber, zoneLetter: utm.zoneLetter });\r\n  const topRight = UTMtoLL({ easting: eastingMax, northing: northingMax, zoneNumber: utm.zoneNumber, zoneLetter: utm.zoneLetter });\r\n  const topLeft = UTMtoLL({ easting: eastingMin, northing: northingMax, zoneNumber: utm.zoneNumber, zoneLetter: utm.zoneLetter });\r\n\r\n  return [\r\n      [bottomLeft.lon, bottomLeft.lat],\r\n      [bottomRight.lon, bottomRight.lat],\r\n      [topRight.lon, topRight.lat],\r\n      [topLeft.lon, topLeft.lat],\r\n      [bottomLeft.lon, bottomLeft.lat] // Close the polygon\r\n  ];\r\n}\r\n\r\nexport function toPoint(mgrs) {\r\n  if (mgrs === '') {\r\n    throw new TypeError('toPoint received a blank string');\r\n  }\r\n  const bbox = UTMtoLL(decode(mgrs.toUpperCase()));\r\n  if (typeof bbox.lat === 'number' && typeof bbox.lon === 'number') {\r\n    return [bbox.lon, bbox.lat];\r\n  }\r\n  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\r\n}\r\n\r\n/**\r\n * Conversion from degrees to radians.\r\n *\r\n * @private\r\n * @param {number} deg the angle in degrees.\r\n * @return {number} the angle in radians.\r\n */\r\nfunction degToRad(deg) {\r\n  return (deg * (Math.PI / 180));\r\n}\r\n\r\n/**\r\n * Conversion from radians to degrees.\r\n *\r\n * @private\r\n * @param {number} rad the angle in radians.\r\n * @return {number} the angle in degrees.\r\n */\r\nfunction radToDeg(rad) {\r\n  return (180 * (rad / Math.PI));\r\n}\r\n\r\n/**\r\n * Converts a set of Longitude and Latitude co-ordinates to UTM\r\n * using the WGS84 ellipsoid.\r\n *\r\n * @private\r\n * @param {object} ll Object literal with lat and lon properties\r\n *     representing the WGS84 coordinate to be converted.\r\n * @return {object} Object literal containing the UTM value with easting,\r\n *     northing, zoneNumber and zoneLetter properties, and an optional\r\n *     accuracy property in digits. Returns null if the conversion failed.\r\n */\r\nfunction LLtoUTM(ll) {\r\n  const Lat = ll.lat;\r\n  const Long = ll.lon;\r\n  const a = SEMI_MAJOR_AXIS;\r\n  const LatRad = degToRad(Lat);\r\n  const LongRad = degToRad(Long);\r\n  let ZoneNumber;\r\n  // (int)\r\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\r\n\r\n  //Make sure the longitude 180 is in Zone 60\r\n  if (Long === 180) {\r\n    ZoneNumber = 60;\r\n  }\r\n\r\n  // Special zone for Norway\r\n  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {\r\n    ZoneNumber = 32;\r\n  }\r\n\r\n  // Special zones for Svalbard\r\n  if (Lat >= 72 && Lat < 84) {\r\n    if (Long >= 0 && Long < 9) {\r\n      ZoneNumber = 31;\r\n    }\r\n    else if (Long >= 9 && Long < 21) {\r\n      ZoneNumber = 33;\r\n    }\r\n    else if (Long >= 21 && Long < 33) {\r\n      ZoneNumber = 35;\r\n    }\r\n    else if (Long >= 33 && Long < 42) {\r\n      ZoneNumber = 37;\r\n    }\r\n  }\r\n\r\n  // +HALF_UTM_ZONE_WIDTH puts origin in middle of zone\r\n  const LongOrigin = (ZoneNumber - 1) * UTM_ZONE_WIDTH - 180 + HALF_UTM_ZONE_WIDTH;\r\n\r\n  const LongOriginRad = degToRad(LongOrigin);\r\n\r\n  const eccPrimeSquared = (ECC_SQUARED) / (1 - ECC_SQUARED);\r\n\r\n  const N = a / Math.sqrt(1 - ECC_SQUARED * Math.sin(LatRad) * Math.sin(LatRad));\r\n  const T = Math.tan(LatRad) * Math.tan(LatRad);\r\n  const C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\r\n  const A = Math.cos(LatRad) * (LongRad - LongOriginRad);\r\n\r\n  const M = a * ((1 - ECC_SQUARED / 4 - 3 * ECC_SQUARED * ECC_SQUARED / 64 - 5 * ECC_SQUARED * ECC_SQUARED * ECC_SQUARED / 256) * LatRad - (3 * ECC_SQUARED / 8 + 3 * ECC_SQUARED * ECC_SQUARED / 32 + 45 * ECC_SQUARED * ECC_SQUARED * ECC_SQUARED / 1024) * Math.sin(2 * LatRad) + (15 * ECC_SQUARED * ECC_SQUARED / 256 + 45 * ECC_SQUARED * ECC_SQUARED * ECC_SQUARED / 1024) * Math.sin(4 * LatRad) - (35 * ECC_SQUARED * ECC_SQUARED * ECC_SQUARED / 3072) * Math.sin(6 * LatRad));\r\n\r\n  const UTMEasting = (SCALE_FACTOR * N * (A + (1 - T + C) * A * A * A / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120) + EASTING_OFFSET);\r\n\r\n  let UTMNorthing = (SCALE_FACTOR * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720)));\r\n  if (Lat < 0) {\r\n    UTMNorthing += NORTHING_OFFFSET;\r\n  }\r\n\r\n  return {\r\n    northing: Math.trunc(UTMNorthing),\r\n    easting: Math.trunc(UTMEasting),\r\n    zoneNumber: ZoneNumber,\r\n    zoneLetter: getLetterDesignator(Lat)\r\n  };\r\n}\r\n\r\n/**\r\n * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\r\n * class where the Zone can be specified as a single string eg.\"60N\" which\r\n * is then broken down into the ZoneNumber and ZoneLetter.\r\n *\r\n * @private\r\n * @param {object} utm An object literal with northing, easting, zoneNumber\r\n *     and zoneLetter properties. If an optional accuracy property is\r\n *     provided (in meters), a bounding box will be returned instead of\r\n *     latitude and longitude.\r\n * @return {object} An object literal containing either lat and lon values\r\n *     (if no accuracy was provided), or top, right, bottom and left values\r\n *     for the bounding box calculated according to the provided accuracy.\r\n *     Returns null if the conversion failed.\r\n */\r\nfunction UTMtoLL(utm) {\r\n\r\n  const UTMNorthing = utm.northing;\r\n  const UTMEasting = utm.easting;\r\n  const { zoneLetter, zoneNumber } = utm;\r\n  // check the ZoneNummber is valid\r\n  if (zoneNumber < 0 || zoneNumber > 60) {\r\n    return null;\r\n  }\r\n\r\n  const a = SEMI_MAJOR_AXIS;\r\n  const e1 = (1 - Math.sqrt(1 - ECC_SQUARED)) / (1 + Math.sqrt(1 - ECC_SQUARED));\r\n\r\n  // remove 500,000 meter offset for longitude\r\n  const x = UTMEasting - EASTING_OFFSET;\r\n  let y = UTMNorthing;\r\n\r\n  // We must know somehow if we are in the Northern or Southern\r\n  // hemisphere, this is the only time we use the letter So even\r\n  // if the Zone letter isn't exactly correct it should indicate\r\n  // the hemisphere correctly\r\n  if (zoneLetter < 'N') {\r\n    y -= NORTHING_OFFFSET; // remove offset used for southern hemisphere\r\n  }\r\n\r\n  // +HALF_UTM_ZONE_WIDTH puts origin in middle of zone\r\n  const LongOrigin = (zoneNumber - 1) * UTM_ZONE_WIDTH - 180 + HALF_UTM_ZONE_WIDTH;\r\n\r\n  const eccPrimeSquared = (ECC_SQUARED) / (1 - ECC_SQUARED);\r\n\r\n  const M = y / SCALE_FACTOR;\r\n  const mu = M / (a * (1 - ECC_SQUARED / 4 - 3 * ECC_SQUARED * ECC_SQUARED / 64 - 5 * ECC_SQUARED * ECC_SQUARED * ECC_SQUARED / 256));\r\n\r\n  const phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\r\n  // double phi1 = ProjMath.radToDeg(phi1Rad);\r\n\r\n  const N1 = a / Math.sqrt(1 - ECC_SQUARED * Math.sin(phi1Rad) * Math.sin(phi1Rad));\r\n  const T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\r\n  const C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\r\n  const R1 = a * (1 - ECC_SQUARED) / Math.pow(1 - ECC_SQUARED * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\r\n  const D = x / (N1 * SCALE_FACTOR);\r\n\r\n  let lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\r\n  lat = radToDeg(lat);\r\n\r\n  let lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\r\n  lon = LongOrigin + radToDeg(lon);\r\n\r\n  let result;\r\n  if (typeof utm.accuracy === 'number') {\r\n    const topRight = UTMtoLL({\r\n      northing: utm.northing + utm.accuracy,\r\n      easting: utm.easting + utm.accuracy,\r\n      zoneLetter: utm.zoneLetter,\r\n      zoneNumber: utm.zoneNumber\r\n    });\r\n    result = {\r\n      top: topRight.lat,\r\n      right: topRight.lon,\r\n      bottom: lat,\r\n      left: lon\r\n    };\r\n  }\r\n  else {\r\n    result = {\r\n      lat,\r\n      lon\r\n    };\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Calculates the MGRS letter designator for the given latitude.\r\n *\r\n * @private (Not intended for public API, only exported for testing.)\r\n * @param {number} latitude The latitude in WGS84 to get the letter designator\r\n *     for.\r\n * @return {string} The letter designator.\r\n */\r\nexport function getLetterDesignator(latitude) {\r\n  if (latitude <= 84 && latitude >= 72) {\r\n    // the X band is 12 degrees high\r\n    return 'X';\r\n  } else if (latitude < 72 && latitude >= -80) {\r\n    // Latitude bands are lettered C through X, excluding I and O\r\n    const bandLetters = 'CDEFGHJKLMNPQRSTUVWX';\r\n    const bandHeight = 8;\r\n    const minLatitude = -80;\r\n    const index = Math.floor((latitude - minLatitude) / bandHeight);\r\n    return bandLetters[index];\r\n  } else if (latitude > 84 || latitude < -80) {\r\n    //This is here as an error flag to show that the Latitude is\r\n    //outside MGRS limits\r\n    return 'Z';\r\n  }\r\n}\r\n\r\n/**\r\n * Encodes a UTM location as MGRS string.\r\n *\r\n * @private\r\n * @param {object} utm An object literal with easting, northing,\r\n *     zoneLetter, zoneNumber\r\n * @param {number} accuracy Accuracy in digits (0-5).\r\n * @return {string} MGRS string for the given UTM location.\r\n */\r\nfunction encode(utm, accuracy) {\r\n  // prepend with leading zeroes\r\n  const seasting = '00000' + utm.easting,\r\n    snorthing = '00000' + utm.northing;\r\n\r\n  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\r\n}\r\n\r\n/**\r\n * Get the two letter 100k designator for a given UTM easting,\r\n * northing and zone number value.\r\n *\r\n * @private\r\n * @param {number} easting\r\n * @param {number} northing\r\n * @param {number} zoneNumber\r\n * @return {string} the two letter 100k designator for the given UTM location.\r\n */\r\nfunction get100kID(easting, northing, zoneNumber) {\r\n  const setParm = get100kSetForZone(zoneNumber);\r\n  const setColumn = Math.floor(easting / 100000);\r\n  const setRow = Math.floor(northing / 100000) % 20;\r\n  return getLetter100kID(setColumn, setRow, setParm);\r\n}\r\n\r\n/**\r\n * Given a UTM zone number, figure out the MGRS 100K set it is in.\r\n *\r\n * @private\r\n * @param {number} i An UTM zone number.\r\n * @return {number} the 100k set the UTM zone is in.\r\n */\r\nfunction get100kSetForZone(i) {\r\n  let setParm = i % NUM_100K_SETS;\r\n  if (setParm === 0) {\r\n    setParm = NUM_100K_SETS;\r\n  }\r\n\r\n  return setParm;\r\n}\r\n\r\n/**\r\n * Get the two-letter MGRS 100k designator given information\r\n * translated from the UTM northing, easting and zone number.\r\n *\r\n * @private\r\n * @param {number} column the column index as it relates to the MGRS\r\n *        100k set spreadsheet, created from the UTM easting.\r\n *        Values are 1-8.\r\n * @param {number} row the row index as it relates to the MGRS 100k set\r\n *        spreadsheet, created from the UTM northing value. Values\r\n *        are from 0-19.\r\n * @param {number} parm the set block, as it relates to the MGRS 100k set\r\n *        spreadsheet, created from the UTM zone. Values are from\r\n *        1-60.\r\n * @return {string} two letter MGRS 100k code.\r\n */\r\nfunction getLetter100kID(column, row, parm) {\r\n  // colOrigin and rowOrigin are the letters at the origin of the set\r\n  const index = parm - 1;\r\n  const colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\r\n  const rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\r\n\r\n  // colInt and rowInt are the letters to build to return\r\n  let colInt = colOrigin + column - 1;\r\n  let rowInt = rowOrigin + row;\r\n  let rollover = false;\r\n\r\n  if (colInt > Z) {\r\n    colInt = colInt - Z + A - 1;\r\n    rollover = true;\r\n  }\r\n\r\n  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\r\n    colInt++;\r\n  }\r\n\r\n  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\r\n    colInt++;\r\n\r\n    if (colInt === I) {\r\n      colInt++;\r\n    }\r\n  }\r\n\r\n  if (colInt > Z) {\r\n    colInt = colInt - Z + A - 1;\r\n  }\r\n\r\n  if (rowInt > V) {\r\n    rowInt = rowInt - V + A - 1;\r\n    rollover = true;\r\n  }\r\n  else {\r\n    rollover = false;\r\n  }\r\n\r\n  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\r\n    rowInt++;\r\n  }\r\n\r\n  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\r\n    rowInt++;\r\n\r\n    if (rowInt === I) {\r\n      rowInt++;\r\n    }\r\n  }\r\n\r\n  if (rowInt > V) {\r\n    rowInt = rowInt - V + A - 1;\r\n  }\r\n\r\n  const twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\r\n  return twoLetter;\r\n}\r\n\r\n/**\r\n * Decode the UTM parameters from a MGRS string.\r\n *\r\n * @private\r\n * @param {string} mgrsString an UPPERCASE coordinate string is expected.\r\n * @return {object} An object literal with easting, northing, zoneLetter,\r\n *     zoneNumber and accuracy (in meters) properties.\r\n */\r\nfunction decode(mgrsString) {\r\n\r\n  if (mgrsString && mgrsString.length === 0) {\r\n    throw new TypeError('MGRSPoint coverting from nothing');\r\n  }\r\n\r\n  //remove any spaces in MGRS String\r\n  mgrsString = mgrsString.replace(/ /g, '');\r\n\r\n  const { length } = mgrsString;\r\n\r\n  let hunK = null;\r\n  let sb = '';\r\n  let testChar;\r\n  let i = 0;\r\n\r\n  // get Zone number\r\n  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\r\n    if (i >= 2) {\r\n      throw new Error(`MGRSPoint bad conversion from: ${mgrsString}`);\r\n    }\r\n    sb += testChar;\r\n    i++;\r\n  }\r\n\r\n  const zoneNumber = parseInt(sb, 10);\r\n\r\n  if (i === 0 || i + 3 > length) {\r\n    // A good MGRS string has to be 4-5 digits long,\r\n    // ##AAA/#AAA at least.\r\n    throw new Error(`MGRSPoint bad conversion from ${mgrsString}`);\r\n  }\r\n\r\n  const zoneLetter = mgrsString.charAt(i++);\r\n\r\n  // Should we check the zone letter here? Why not.\r\n  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\r\n    throw new Error(`MGRSPoint zone letter ${zoneLetter} not handled: ${mgrsString}`);\r\n  }\r\n\r\n  hunK = mgrsString.substring(i, i += 2);\r\n\r\n  const set = get100kSetForZone(zoneNumber);\r\n\r\n  const east100k = getEastingFromChar(hunK.charAt(0), set);\r\n  let north100k = getNorthingFromChar(hunK.charAt(1), set);\r\n\r\n  // We have a bug where the northing may be 2000000 too low.\r\n  // How\r\n  // do we know when to roll over?\r\n\r\n  while (north100k < getMinNorthing(zoneLetter)) {\r\n    north100k += 2000000;\r\n  }\r\n\r\n  // calculate the char index for easting/northing separator\r\n  const remainder = length - i;\r\n\r\n  if (remainder % 2 !== 0) {\r\n    throw new Error(`MGRSPoint has to have an even number\r\nof digits after the zone letter and two 100km letters - front\r\nhalf for easting meters, second half for\r\nnorthing meters ${mgrsString}`);\r\n  }\r\n\r\n  const sep = remainder / 2;\r\n\r\n  let sepEasting = 0;\r\n  let sepNorthing = 0;\r\n  let accuracyBonus, sepEastingString, sepNorthingString;\r\n  if (sep > 0) {\r\n    accuracyBonus = 100000 / Math.pow(10, sep);\r\n    sepEastingString = mgrsString.substring(i, i + sep);\r\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\r\n    sepNorthingString = mgrsString.substring(i + sep);\r\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\r\n  }\r\n\r\n  const easting = sepEasting + east100k;\r\n  const northing = sepNorthing + north100k;\r\n\r\n  return {\r\n    easting,\r\n    northing,\r\n    zoneLetter,\r\n    zoneNumber,\r\n    accuracy: accuracyBonus\r\n  };\r\n}\r\n\r\n/**\r\n * Given the first letter from a two-letter MGRS 100k zone, and given the\r\n * MGRS table set for the zone number, figure out the easting value that\r\n * should be added to the other, secondary easting value.\r\n *\r\n * @private\r\n * @param {string} e The first letter from a two-letter MGRS 100´k zone.\r\n * @param {number} set The MGRS table set for the zone number.\r\n * @return {number} The easting value for the given letter and set.\r\n */\r\nfunction getEastingFromChar(e, set) {\r\n  // colOrigin is the letter at the origin of the set for the\r\n  // column\r\n  let curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\r\n  let eastingValue = 100000;\r\n  let rewindMarker = false;\r\n\r\n  while (curCol !== e.charCodeAt(0)) {\r\n    curCol++;\r\n    if (curCol === I) {\r\n      curCol++;\r\n    }\r\n    if (curCol === O) {\r\n      curCol++;\r\n    }\r\n    if (curCol > Z) {\r\n      if (rewindMarker) {\r\n        throw new Error(`Bad character: ${e}`);\r\n      }\r\n      curCol = A;\r\n      rewindMarker = true;\r\n    }\r\n    eastingValue += 100000;\r\n  }\r\n\r\n  return eastingValue;\r\n}\r\n\r\n/**\r\n * Given the second letter from a two-letter MGRS 100k zone, and given the\r\n * MGRS table set for the zone number, figure out the northing value that\r\n * should be added to the other, secondary northing value. You have to\r\n * remember that Northings are determined from the equator, and the vertical\r\n * cycle of letters mean a 2000000 additional northing meters. This happens\r\n * approx. every 18 degrees of latitude. This method does *NOT* count any\r\n * additional northings. You have to figure out how many 2000000 meters need\r\n * to be added for the zone letter of the MGRS coordinate.\r\n *\r\n * @private\r\n * @param {string} n Second letter of the MGRS 100k zone\r\n * @param {number} set The MGRS table set number, which is dependent on the\r\n *     UTM zone number.\r\n * @return {number} The northing value for the given letter and set.\r\n */\r\nfunction getNorthingFromChar(n, set) {\r\n\r\n  if (n > 'V') {\r\n    throw new TypeError(`MGRSPoint given invalid Northing ${n}`);\r\n  }\r\n\r\n  // rowOrigin is the letter at the origin of the set for the\r\n  // column\r\n  let curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\r\n  let northingValue = 0;\r\n  let rewindMarker = false;\r\n\r\n  while (curRow !== n.charCodeAt(0)) {\r\n    curRow++;\r\n    if (curRow === I) {\r\n      curRow++;\r\n    }\r\n    if (curRow === O) {\r\n      curRow++;\r\n    }\r\n    // fixing a bug making whole application hang in this loop\r\n    // when 'n' is a wrong character\r\n    if (curRow > V) {\r\n      if (rewindMarker) { // making sure that this loop ends\r\n        throw new Error(`Bad character: ${n}`);\r\n      }\r\n      curRow = A;\r\n      rewindMarker = true;\r\n    }\r\n    northingValue += 100000;\r\n  }\r\n\r\n  return northingValue;\r\n}\r\n\r\n/**\r\n * The function getMinNorthing returns the minimum northing value of a MGRS\r\n * zone.\r\n *\r\n * Ported from Geotrans' c Lattitude_Band_Value structure table.\r\n *\r\n * @private\r\n * @param {string} zoneLetter The MGRS zone to get the min northing for.\r\n * @return {number}\r\n */\r\nfunction getMinNorthing(zoneLetter) {\r\n  let northing;\r\n  switch (zoneLetter) {\r\n  case 'C':\r\n    northing = 1100000;\r\n    break;\r\n  case 'D':\r\n    northing = 2000000;\r\n    break;\r\n  case 'E':\r\n    northing = 2800000;\r\n    break;\r\n  case 'F':\r\n    northing = 3700000;\r\n    break;\r\n  case 'G':\r\n    northing = 4600000;\r\n    break;\r\n  case 'H':\r\n    northing = 5500000;\r\n    break;\r\n  case 'J':\r\n    northing = 6400000;\r\n    break;\r\n  case 'K':\r\n    northing = 7300000;\r\n    break;\r\n  case 'L':\r\n    northing = 8200000;\r\n    break;\r\n  case 'M':\r\n    northing = 9100000;\r\n    break;\r\n  case 'N':\r\n    northing = 0;\r\n    break;\r\n  case 'P':\r\n    northing = 800000;\r\n    break;\r\n  case 'Q':\r\n    northing = 1700000;\r\n    break;\r\n  case 'R':\r\n    northing = 2600000;\r\n    break;\r\n  case 'S':\r\n    northing = 3500000;\r\n    break;\r\n  case 'T':\r\n    northing = 4400000;\r\n    break;\r\n  case 'U':\r\n    northing = 5300000;\r\n    break;\r\n  case 'V':\r\n    northing = 6200000;\r\n    break;\r\n  case 'W':\r\n    northing = 7000000;\r\n    break;\r\n  case 'X':\r\n    northing = 7900000;\r\n    break;\r\n  default:\r\n    northing = -1;\r\n  }\r\n  if (northing >= 0) {\r\n    return northing;\r\n  }\r\n  else {\r\n    throw new TypeError(`Invalid zone letter: ${zoneLetter}`);\r\n  }\r\n\r\n}\r\n"],"names":["A","I","O","forward","ll","accuracy","Array","isArray","TypeError","lon","lat","utm","seasting","easting","snorthing","northing","zoneNumber","zoneLetter","setParm","get100kSetForZone","setColumn","Math","floor","setRow","column","row","parm","index","colOrigin","charCodeAt","rowOrigin","colInt","rowInt","rollover","String","fromCharCode","getLetter100kID","get100kID","substr","length","encode","Lat","Long","a","LatRad","degToRad","LongRad","ZoneNumber","LongOriginRad","UTM_ZONE_WIDTH","N","sqrt","sin","T","tan","C","cos","M","UTMEasting","UTMNorthing","trunc","getLetterDesignator","LLtoUTM","inverse","mgrs","bbox","UTMtoLL","decode","toUpperCase","left","bottom","right","top","polygon","mgrsString","eastingMin","northingMin","eastingMax","northingMax","bottomLeft","bottomRight","topRight","topLeft","toPoint","deg","PI","radToDeg","rad","e1","x","y","LongOrigin","mu","phi1Rad","N1","T1","C1","R1","pow","D","result","latitude","bandHeight","minLatitude","i","replace","testChar","hunK","sb","test","charAt","Error","parseInt","substring","set","east100k","e","curCol","eastingValue","rewindMarker","getEastingFromChar","north100k","n","curRow","northingValue","getNorthingFromChar","getMinNorthing","remainder","sep","accuracyBonus","sepEastingString","sepNorthingString","sepEasting","sepNorthing","parseFloat"],"mappings":"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"}